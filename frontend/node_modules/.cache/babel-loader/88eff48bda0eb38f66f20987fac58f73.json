{"ast":null,"code":"import { parse, SelectorType, isTraversal } from \"css-what\";\nimport { _compileToken as compileToken, prepareContext } from \"css-select\";\nimport * as DomUtils from \"domutils\";\nimport * as boolbase from \"boolbase\";\nimport { getDocumentRoot, groupSelectors } from \"./helpers.js\";\nimport { isFilter, getLimit } from \"./positionals.js\";\n// Re-export pseudo extension points\nexport { filters, pseudos, aliases } from \"css-select\";\nconst UNIVERSAL_SELECTOR = {\n  type: SelectorType.Universal,\n  namespace: null\n};\nconst SCOPE_PSEUDO = {\n  type: SelectorType.Pseudo,\n  name: \"scope\",\n  data: null\n};\nexport function is(element, selector) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  return some([element], selector, options);\n}\nexport function some(elements, selector) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  if (typeof selector === \"function\") return elements.some(selector);\n  const [plain, filtered] = groupSelectors(parse(selector));\n  return plain.length > 0 && elements.some(compileToken(plain, options)) || filtered.some(sel => filterBySelector(sel, elements, options).length > 0);\n}\nfunction filterByPosition(filter, elems, data, options) {\n  const num = typeof data === \"string\" ? parseInt(data, 10) : NaN;\n  switch (filter) {\n    case \"first\":\n    case \"lt\":\n      // Already done in `getLimit`\n      return elems;\n    case \"last\":\n      return elems.length > 0 ? [elems[elems.length - 1]] : elems;\n    case \"nth\":\n    case \"eq\":\n      return isFinite(num) && Math.abs(num) < elems.length ? [num < 0 ? elems[elems.length + num] : elems[num]] : [];\n    case \"gt\":\n      return isFinite(num) ? elems.slice(num + 1) : [];\n    case \"even\":\n      return elems.filter((_, i) => i % 2 === 0);\n    case \"odd\":\n      return elems.filter((_, i) => i % 2 === 1);\n    case \"not\":\n      {\n        const filtered = new Set(filterParsed(data, elems, options));\n        return elems.filter(e => !filtered.has(e));\n      }\n  }\n}\nexport function filter(selector, elements) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  return filterParsed(parse(selector), elements, options);\n}\n/**\n * Filter a set of elements by a selector.\n *\n * Will return elements in the original order.\n *\n * @param selector Selector to filter by.\n * @param elements Elements to filter.\n * @param options Options for selector.\n */\nfunction filterParsed(selector, elements, options) {\n  if (elements.length === 0) return [];\n  const [plainSelectors, filteredSelectors] = groupSelectors(selector);\n  let found;\n  if (plainSelectors.length) {\n    const filtered = filterElements(elements, plainSelectors, options);\n    // If there are no filters, just return\n    if (filteredSelectors.length === 0) {\n      return filtered;\n    }\n    // Otherwise, we have to do some filtering\n    if (filtered.length) {\n      found = new Set(filtered);\n    }\n  }\n  for (let i = 0; i < filteredSelectors.length && (found === null || found === void 0 ? void 0 : found.size) !== elements.length; i++) {\n    const filteredSelector = filteredSelectors[i];\n    const missing = found ? elements.filter(e => DomUtils.isTag(e) && !found.has(e)) : elements;\n    if (missing.length === 0) break;\n    const filtered = filterBySelector(filteredSelector, elements, options);\n    if (filtered.length) {\n      if (!found) {\n        /*\n         * If we haven't found anything before the last selector,\n         * just return what we found now.\n         */\n        if (i === filteredSelectors.length - 1) {\n          return filtered;\n        }\n        found = new Set(filtered);\n      } else {\n        filtered.forEach(el => found.add(el));\n      }\n    }\n  }\n  return typeof found !== \"undefined\" ? found.size === elements.length ? elements :\n  // Filter elements to preserve order\n  elements.filter(el => found.has(el)) : [];\n}\nfunction filterBySelector(selector, elements, options) {\n  var _a;\n  if (selector.some(isTraversal)) {\n    /*\n     * Get root node, run selector with the scope\n     * set to all of our nodes.\n     */\n    const root = (_a = options.root) !== null && _a !== void 0 ? _a : getDocumentRoot(elements[0]);\n    const opts = {\n      ...options,\n      context: elements,\n      relativeSelector: false\n    };\n    selector.push(SCOPE_PSEUDO);\n    return findFilterElements(root, selector, opts, true, elements.length);\n  }\n  // Performance optimization: If we don't have to traverse, just filter set.\n  return findFilterElements(elements, selector, options, false, elements.length);\n}\nexport function select(selector, root) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  let limit = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Infinity;\n  if (typeof selector === \"function\") {\n    return find(root, selector);\n  }\n  const [plain, filtered] = groupSelectors(parse(selector));\n  const results = filtered.map(sel => findFilterElements(root, sel, options, true, limit));\n  // Plain selectors can be queried in a single go\n  if (plain.length) {\n    results.push(findElements(root, plain, options, limit));\n  }\n  if (results.length === 0) {\n    return [];\n  }\n  // If there was only a single selector, just return the result\n  if (results.length === 1) {\n    return results[0];\n  }\n  // Sort results, filtering for duplicates\n  return DomUtils.uniqueSort(results.reduce((a, b) => [...a, ...b]));\n}\n/**\n *\n * @param root Element(s) to search from.\n * @param selector Selector to look for.\n * @param options Options for querying.\n * @param queryForSelector Query multiple levels deep for the initial selector, even if it doesn't contain a traversal.\n */\nfunction findFilterElements(root, selector, options, queryForSelector, totalLimit) {\n  const filterIndex = selector.findIndex(isFilter);\n  const sub = selector.slice(0, filterIndex);\n  const filter = selector[filterIndex];\n  // If we are at the end of the selector, we can limit the number of elements to retrieve.\n  const partLimit = selector.length - 1 === filterIndex ? totalLimit : Infinity;\n  /*\n   * Set the number of elements to retrieve.\n   * Eg. for :first, we only have to get a single element.\n   */\n  const limit = getLimit(filter.name, filter.data, partLimit);\n  if (limit === 0) return [];\n  /*\n   * Skip `findElements` call if our selector starts with a positional\n   * pseudo.\n   */\n  const elemsNoLimit = sub.length === 0 && !Array.isArray(root) ? DomUtils.getChildren(root).filter(DomUtils.isTag) : sub.length === 0 ? (Array.isArray(root) ? root : [root]).filter(DomUtils.isTag) : queryForSelector || sub.some(isTraversal) ? findElements(root, [sub], options, limit) : filterElements(root, [sub], options);\n  const elems = elemsNoLimit.slice(0, limit);\n  let result = filterByPosition(filter.name, elems, filter.data, options);\n  if (result.length === 0 || selector.length === filterIndex + 1) {\n    return result;\n  }\n  const remainingSelector = selector.slice(filterIndex + 1);\n  const remainingHasTraversal = remainingSelector.some(isTraversal);\n  if (remainingHasTraversal) {\n    if (isTraversal(remainingSelector[0])) {\n      const {\n        type\n      } = remainingSelector[0];\n      if (type === SelectorType.Sibling || type === SelectorType.Adjacent) {\n        // If we have a sibling traversal, we need to also look at the siblings.\n        result = prepareContext(result, DomUtils, true);\n      }\n      // Avoid a traversal-first selector error.\n      remainingSelector.unshift(UNIVERSAL_SELECTOR);\n    }\n    options = {\n      ...options,\n      // Avoid absolutizing the selector\n      relativeSelector: false,\n      /*\n       * Add a custom root func, to make sure traversals don't match elements\n       * that aren't a part of the considered tree.\n       */\n      rootFunc: el => result.includes(el)\n    };\n  } else if (options.rootFunc && options.rootFunc !== boolbase.trueFunc) {\n    options = {\n      ...options,\n      rootFunc: boolbase.trueFunc\n    };\n  }\n  /*\n   * If we have another filter, recursively call `findFilterElements`,\n   * with the `recursive` flag disabled. We only have to look for more\n   * elements when we see a traversal.\n   *\n   * Otherwise,\n   */\n  return remainingSelector.some(isFilter) ? findFilterElements(result, remainingSelector, options, false, totalLimit) : remainingHasTraversal ?\n  // Query existing elements to resolve traversal.\n  findElements(result, [remainingSelector], options, totalLimit) :\n  // If we don't have any more traversals, simply filter elements.\n  filterElements(result, [remainingSelector], options);\n}\nfunction findElements(root, sel, options, limit) {\n  const query = compileToken(sel, options, root);\n  return find(root, query, limit);\n}\nfunction find(root, query) {\n  let limit = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Infinity;\n  const elems = prepareContext(root, DomUtils, query.shouldTestNextSiblings);\n  return DomUtils.find(node => DomUtils.isTag(node) && query(node), elems, true, limit);\n}\nfunction filterElements(elements, sel, options) {\n  const els = (Array.isArray(elements) ? elements : [elements]).filter(DomUtils.isTag);\n  if (els.length === 0) return els;\n  const query = compileToken(sel, options);\n  return query === boolbase.trueFunc ? els : els.filter(query);\n}","map":{"version":3,"mappings":"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","names":["parse","SelectorType","isTraversal","_compileToken","compileToken","prepareContext","DomUtils","boolbase","getDocumentRoot","groupSelectors","isFilter","getLimit","filters","pseudos","aliases","UNIVERSAL_SELECTOR","type","Universal","namespace","SCOPE_PSEUDO","Pseudo","name","data","is","element","selector","options","some","elements","plain","filtered","length","sel","filterBySelector","filterByPosition","filter","elems","num","parseInt","NaN","isFinite","Math","abs","slice","_","i","Set","filterParsed","e","has","plainSelectors","filteredSelectors","found","filterElements","size","filteredSelector","missing","isTag","forEach","el","add","root","opts","context","relativeSelector","push","findFilterElements","select","limit","Infinity","find","results","map","findElements","uniqueSort","reduce","a","b","queryForSelector","totalLimit","filterIndex","findIndex","sub","partLimit","elemsNoLimit","Array","isArray","getChildren","result","remainingSelector","remainingHasTraversal","Sibling","Adjacent","unshift","rootFunc","includes","trueFunc","query","shouldTestNextSiblings","node","els"],"sources":["index.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}