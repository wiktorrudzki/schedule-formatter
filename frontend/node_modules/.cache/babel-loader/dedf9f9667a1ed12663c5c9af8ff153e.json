{"ast":null,"code":"import _classCallCheck from \"C:/programowanko/react/schedule-formatter/schedule-formatter/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/programowanko/react/schedule-formatter/schedule-formatter/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { CODE_POINTS as $, getSurrogatePairCodePoint, isControlCodePoint, isSurrogate, isSurrogatePair, isUndefinedCodePoint } from '../common/unicode.js';\nimport { ERR } from '../common/error-codes.js';\n//Const\nvar DEFAULT_BUFFER_WATERLINE = 1 << 16;\n//Preprocessor\n//NOTE: HTML input preprocessing\n//(see: http://www.whatwg.org/specs/web-apps/current-work/multipage/parsing.html#preprocessing-the-input-stream)\nexport var Preprocessor = /*#__PURE__*/function () {\n  function Preprocessor(handler) {\n    _classCallCheck(this, Preprocessor);\n    this.handler = handler;\n    this.html = '';\n    this.pos = -1;\n    // NOTE: Initial `lastGapPos` is -2, to ensure `col` on initialisation is 0\n    this.lastGapPos = -2;\n    this.gapStack = [];\n    this.skipNextNewLine = false;\n    this.lastChunkWritten = false;\n    this.endOfChunkHit = false;\n    this.bufferWaterline = DEFAULT_BUFFER_WATERLINE;\n    this.isEol = false;\n    this.lineStartPos = 0;\n    this.droppedBufferSize = 0;\n    this.line = 1;\n    //NOTE: avoid reporting errors twice on advance/retreat\n    this.lastErrOffset = -1;\n  }\n  /** The column on the current line. If we just saw a gap (eg. a surrogate pair), return the index before. */\n  _createClass(Preprocessor, [{\n    key: \"col\",\n    get: function get() {\n      return this.pos - this.lineStartPos + Number(this.lastGapPos !== this.pos);\n    }\n  }, {\n    key: \"offset\",\n    get: function get() {\n      return this.droppedBufferSize + this.pos;\n    }\n  }, {\n    key: \"getError\",\n    value: function getError(code) {\n      var line = this.line,\n        col = this.col,\n        offset = this.offset;\n      return {\n        code: code,\n        startLine: line,\n        endLine: line,\n        startCol: col,\n        endCol: col,\n        startOffset: offset,\n        endOffset: offset\n      };\n    }\n  }, {\n    key: \"_err\",\n    value: function _err(code) {\n      if (this.handler.onParseError && this.lastErrOffset !== this.offset) {\n        this.lastErrOffset = this.offset;\n        this.handler.onParseError(this.getError(code));\n      }\n    }\n  }, {\n    key: \"_addGap\",\n    value: function _addGap() {\n      this.gapStack.push(this.lastGapPos);\n      this.lastGapPos = this.pos;\n    }\n  }, {\n    key: \"_processSurrogate\",\n    value: function _processSurrogate(cp) {\n      //NOTE: try to peek a surrogate pair\n      if (this.pos !== this.html.length - 1) {\n        var nextCp = this.html.charCodeAt(this.pos + 1);\n        if (isSurrogatePair(nextCp)) {\n          //NOTE: we have a surrogate pair. Peek pair character and recalculate code point.\n          this.pos++;\n          //NOTE: add a gap that should be avoided during retreat\n          this._addGap();\n          return getSurrogatePairCodePoint(cp, nextCp);\n        }\n      }\n      //NOTE: we are at the end of a chunk, therefore we can't infer the surrogate pair yet.\n      else if (!this.lastChunkWritten) {\n        this.endOfChunkHit = true;\n        return $.EOF;\n      }\n      //NOTE: isolated surrogate\n      this._err(ERR.surrogateInInputStream);\n      return cp;\n    }\n  }, {\n    key: \"willDropParsedChunk\",\n    value: function willDropParsedChunk() {\n      return this.pos > this.bufferWaterline;\n    }\n  }, {\n    key: \"dropParsedChunk\",\n    value: function dropParsedChunk() {\n      if (this.willDropParsedChunk()) {\n        this.html = this.html.substring(this.pos);\n        this.lineStartPos -= this.pos;\n        this.droppedBufferSize += this.pos;\n        this.pos = 0;\n        this.lastGapPos = -2;\n        this.gapStack.length = 0;\n      }\n    }\n  }, {\n    key: \"write\",\n    value: function write(chunk, isLastChunk) {\n      if (this.html.length > 0) {\n        this.html += chunk;\n      } else {\n        this.html = chunk;\n      }\n      this.endOfChunkHit = false;\n      this.lastChunkWritten = isLastChunk;\n    }\n  }, {\n    key: \"insertHtmlAtCurrentPos\",\n    value: function insertHtmlAtCurrentPos(chunk) {\n      this.html = this.html.substring(0, this.pos + 1) + chunk + this.html.substring(this.pos + 1);\n      this.endOfChunkHit = false;\n    }\n  }, {\n    key: \"startsWith\",\n    value: function startsWith(pattern, caseSensitive) {\n      // Check if our buffer has enough characters\n      if (this.pos + pattern.length > this.html.length) {\n        this.endOfChunkHit = !this.lastChunkWritten;\n        return false;\n      }\n      if (caseSensitive) {\n        return this.html.startsWith(pattern, this.pos);\n      }\n      for (var i = 0; i < pattern.length; i++) {\n        var cp = this.html.charCodeAt(this.pos + i) | 0x20;\n        if (cp !== pattern.charCodeAt(i)) {\n          return false;\n        }\n      }\n      return true;\n    }\n  }, {\n    key: \"peek\",\n    value: function peek(offset) {\n      var pos = this.pos + offset;\n      if (pos >= this.html.length) {\n        this.endOfChunkHit = !this.lastChunkWritten;\n        return $.EOF;\n      }\n      return this.html.charCodeAt(pos);\n    }\n  }, {\n    key: \"advance\",\n    value: function advance() {\n      this.pos++;\n      //NOTE: LF should be in the last column of the line\n      if (this.isEol) {\n        this.isEol = false;\n        this.line++;\n        this.lineStartPos = this.pos;\n      }\n      if (this.pos >= this.html.length) {\n        this.endOfChunkHit = !this.lastChunkWritten;\n        return $.EOF;\n      }\n      var cp = this.html.charCodeAt(this.pos);\n      //NOTE: all U+000D CARRIAGE RETURN (CR) characters must be converted to U+000A LINE FEED (LF) characters\n      if (cp === $.CARRIAGE_RETURN) {\n        this.isEol = true;\n        this.skipNextNewLine = true;\n        return $.LINE_FEED;\n      }\n      //NOTE: any U+000A LINE FEED (LF) characters that immediately follow a U+000D CARRIAGE RETURN (CR) character\n      //must be ignored.\n      if (cp === $.LINE_FEED) {\n        this.isEol = true;\n        if (this.skipNextNewLine) {\n          // `line` will be bumped again in the recursive call.\n          this.line--;\n          this.skipNextNewLine = false;\n          this._addGap();\n          return this.advance();\n        }\n      }\n      this.skipNextNewLine = false;\n      if (isSurrogate(cp)) {\n        cp = this._processSurrogate(cp);\n      }\n      //OPTIMIZATION: first check if code point is in the common allowed\n      //range (ASCII alphanumeric, whitespaces, big chunk of BMP)\n      //before going into detailed performance cost validation.\n      var isCommonValidRange = this.handler.onParseError === null || cp > 0x1f && cp < 0x7f || cp === $.LINE_FEED || cp === $.CARRIAGE_RETURN || cp > 0x9f && cp < 64976;\n      if (!isCommonValidRange) {\n        this._checkForProblematicCharacters(cp);\n      }\n      return cp;\n    }\n  }, {\n    key: \"_checkForProblematicCharacters\",\n    value: function _checkForProblematicCharacters(cp) {\n      if (isControlCodePoint(cp)) {\n        this._err(ERR.controlCharacterInInputStream);\n      } else if (isUndefinedCodePoint(cp)) {\n        this._err(ERR.noncharacterInInputStream);\n      }\n    }\n  }, {\n    key: \"retreat\",\n    value: function retreat(count) {\n      this.pos -= count;\n      while (this.pos < this.lastGapPos) {\n        this.lastGapPos = this.gapStack.pop();\n        this.pos--;\n      }\n      this.isEol = false;\n    }\n  }]);\n  return Preprocessor;\n}();","map":{"version":3,"names":["CODE_POINTS","$","getSurrogatePairCodePoint","isControlCodePoint","isSurrogate","isSurrogatePair","isUndefinedCodePoint","ERR","DEFAULT_BUFFER_WATERLINE","Preprocessor","handler","html","pos","lastGapPos","gapStack","skipNextNewLine","lastChunkWritten","endOfChunkHit","bufferWaterline","isEol","lineStartPos","droppedBufferSize","line","lastErrOffset","Number","code","col","offset","startLine","endLine","startCol","endCol","startOffset","endOffset","onParseError","getError","push","cp","length","nextCp","charCodeAt","_addGap","EOF","_err","surrogateInInputStream","willDropParsedChunk","substring","chunk","isLastChunk","pattern","caseSensitive","startsWith","i","CARRIAGE_RETURN","LINE_FEED","advance","_processSurrogate","isCommonValidRange","_checkForProblematicCharacters","controlCharacterInInputStream","noncharacterInInputStream","count","pop"],"sources":["C:/programowanko/react/schedule-formatter/schedule-formatter/node_modules/parse5-htmlparser2-tree-adapter/node_modules/parse5/dist/tokenizer/preprocessor.js"],"sourcesContent":["import { CODE_POINTS as $, getSurrogatePairCodePoint, isControlCodePoint, isSurrogate, isSurrogatePair, isUndefinedCodePoint, } from '../common/unicode.js';\nimport { ERR } from '../common/error-codes.js';\n//Const\nconst DEFAULT_BUFFER_WATERLINE = 1 << 16;\n//Preprocessor\n//NOTE: HTML input preprocessing\n//(see: http://www.whatwg.org/specs/web-apps/current-work/multipage/parsing.html#preprocessing-the-input-stream)\nexport class Preprocessor {\n    constructor(handler) {\n        this.handler = handler;\n        this.html = '';\n        this.pos = -1;\n        // NOTE: Initial `lastGapPos` is -2, to ensure `col` on initialisation is 0\n        this.lastGapPos = -2;\n        this.gapStack = [];\n        this.skipNextNewLine = false;\n        this.lastChunkWritten = false;\n        this.endOfChunkHit = false;\n        this.bufferWaterline = DEFAULT_BUFFER_WATERLINE;\n        this.isEol = false;\n        this.lineStartPos = 0;\n        this.droppedBufferSize = 0;\n        this.line = 1;\n        //NOTE: avoid reporting errors twice on advance/retreat\n        this.lastErrOffset = -1;\n    }\n    /** The column on the current line. If we just saw a gap (eg. a surrogate pair), return the index before. */\n    get col() {\n        return this.pos - this.lineStartPos + Number(this.lastGapPos !== this.pos);\n    }\n    get offset() {\n        return this.droppedBufferSize + this.pos;\n    }\n    getError(code) {\n        const { line, col, offset } = this;\n        return {\n            code,\n            startLine: line,\n            endLine: line,\n            startCol: col,\n            endCol: col,\n            startOffset: offset,\n            endOffset: offset,\n        };\n    }\n    _err(code) {\n        if (this.handler.onParseError && this.lastErrOffset !== this.offset) {\n            this.lastErrOffset = this.offset;\n            this.handler.onParseError(this.getError(code));\n        }\n    }\n    _addGap() {\n        this.gapStack.push(this.lastGapPos);\n        this.lastGapPos = this.pos;\n    }\n    _processSurrogate(cp) {\n        //NOTE: try to peek a surrogate pair\n        if (this.pos !== this.html.length - 1) {\n            const nextCp = this.html.charCodeAt(this.pos + 1);\n            if (isSurrogatePair(nextCp)) {\n                //NOTE: we have a surrogate pair. Peek pair character and recalculate code point.\n                this.pos++;\n                //NOTE: add a gap that should be avoided during retreat\n                this._addGap();\n                return getSurrogatePairCodePoint(cp, nextCp);\n            }\n        }\n        //NOTE: we are at the end of a chunk, therefore we can't infer the surrogate pair yet.\n        else if (!this.lastChunkWritten) {\n            this.endOfChunkHit = true;\n            return $.EOF;\n        }\n        //NOTE: isolated surrogate\n        this._err(ERR.surrogateInInputStream);\n        return cp;\n    }\n    willDropParsedChunk() {\n        return this.pos > this.bufferWaterline;\n    }\n    dropParsedChunk() {\n        if (this.willDropParsedChunk()) {\n            this.html = this.html.substring(this.pos);\n            this.lineStartPos -= this.pos;\n            this.droppedBufferSize += this.pos;\n            this.pos = 0;\n            this.lastGapPos = -2;\n            this.gapStack.length = 0;\n        }\n    }\n    write(chunk, isLastChunk) {\n        if (this.html.length > 0) {\n            this.html += chunk;\n        }\n        else {\n            this.html = chunk;\n        }\n        this.endOfChunkHit = false;\n        this.lastChunkWritten = isLastChunk;\n    }\n    insertHtmlAtCurrentPos(chunk) {\n        this.html = this.html.substring(0, this.pos + 1) + chunk + this.html.substring(this.pos + 1);\n        this.endOfChunkHit = false;\n    }\n    startsWith(pattern, caseSensitive) {\n        // Check if our buffer has enough characters\n        if (this.pos + pattern.length > this.html.length) {\n            this.endOfChunkHit = !this.lastChunkWritten;\n            return false;\n        }\n        if (caseSensitive) {\n            return this.html.startsWith(pattern, this.pos);\n        }\n        for (let i = 0; i < pattern.length; i++) {\n            const cp = this.html.charCodeAt(this.pos + i) | 0x20;\n            if (cp !== pattern.charCodeAt(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    peek(offset) {\n        const pos = this.pos + offset;\n        if (pos >= this.html.length) {\n            this.endOfChunkHit = !this.lastChunkWritten;\n            return $.EOF;\n        }\n        return this.html.charCodeAt(pos);\n    }\n    advance() {\n        this.pos++;\n        //NOTE: LF should be in the last column of the line\n        if (this.isEol) {\n            this.isEol = false;\n            this.line++;\n            this.lineStartPos = this.pos;\n        }\n        if (this.pos >= this.html.length) {\n            this.endOfChunkHit = !this.lastChunkWritten;\n            return $.EOF;\n        }\n        let cp = this.html.charCodeAt(this.pos);\n        //NOTE: all U+000D CARRIAGE RETURN (CR) characters must be converted to U+000A LINE FEED (LF) characters\n        if (cp === $.CARRIAGE_RETURN) {\n            this.isEol = true;\n            this.skipNextNewLine = true;\n            return $.LINE_FEED;\n        }\n        //NOTE: any U+000A LINE FEED (LF) characters that immediately follow a U+000D CARRIAGE RETURN (CR) character\n        //must be ignored.\n        if (cp === $.LINE_FEED) {\n            this.isEol = true;\n            if (this.skipNextNewLine) {\n                // `line` will be bumped again in the recursive call.\n                this.line--;\n                this.skipNextNewLine = false;\n                this._addGap();\n                return this.advance();\n            }\n        }\n        this.skipNextNewLine = false;\n        if (isSurrogate(cp)) {\n            cp = this._processSurrogate(cp);\n        }\n        //OPTIMIZATION: first check if code point is in the common allowed\n        //range (ASCII alphanumeric, whitespaces, big chunk of BMP)\n        //before going into detailed performance cost validation.\n        const isCommonValidRange = this.handler.onParseError === null ||\n            (cp > 0x1f && cp < 0x7f) ||\n            cp === $.LINE_FEED ||\n            cp === $.CARRIAGE_RETURN ||\n            (cp > 0x9f && cp < 64976);\n        if (!isCommonValidRange) {\n            this._checkForProblematicCharacters(cp);\n        }\n        return cp;\n    }\n    _checkForProblematicCharacters(cp) {\n        if (isControlCodePoint(cp)) {\n            this._err(ERR.controlCharacterInInputStream);\n        }\n        else if (isUndefinedCodePoint(cp)) {\n            this._err(ERR.noncharacterInInputStream);\n        }\n    }\n    retreat(count) {\n        this.pos -= count;\n        while (this.pos < this.lastGapPos) {\n            this.lastGapPos = this.gapStack.pop();\n            this.pos--;\n        }\n        this.isEol = false;\n    }\n}\n//# sourceMappingURL=preprocessor.js.map"],"mappings":"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"},"metadata":{},"sourceType":"module"}