{"ast":null,"code":"import _classCallCheck from \"C:/programowanko/react/schedule-formatter/schedule-formatter/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/programowanko/react/schedule-formatter/schedule-formatter/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { ElementType } from \"domelementtype\";\nimport { Element, Text, Comment, CDATA, Document, ProcessingInstruction } from \"./node.js\";\nexport * from \"./node.js\";\n// Default options\nvar defaultOpts = {\n  withStartIndices: false,\n  withEndIndices: false,\n  xmlMode: false\n};\nexport var DomHandler = /*#__PURE__*/function () {\n  /**\n   * @param callback Called once parsing has completed.\n   * @param options Settings for the handler.\n   * @param elementCB Callback whenever a tag is closed.\n   */\n  function DomHandler(callback, options, elementCB) {\n    _classCallCheck(this, DomHandler);\n    /** The elements of the DOM */\n    this.dom = [];\n    /** The root element for the DOM */\n    this.root = new Document(this.dom);\n    /** Indicated whether parsing has been completed. */\n    this.done = false;\n    /** Stack of open tags. */\n    this.tagStack = [this.root];\n    /** A data node that is still being written to. */\n    this.lastNode = null;\n    /** Reference to the parser instance. Used for location information. */\n    this.parser = null;\n    // Make it possible to skip arguments, for backwards-compatibility\n    if (typeof options === \"function\") {\n      elementCB = options;\n      options = defaultOpts;\n    }\n    if (typeof callback === \"object\") {\n      options = callback;\n      callback = undefined;\n    }\n    this.callback = callback !== null && callback !== void 0 ? callback : null;\n    this.options = options !== null && options !== void 0 ? options : defaultOpts;\n    this.elementCB = elementCB !== null && elementCB !== void 0 ? elementCB : null;\n  }\n  _createClass(DomHandler, [{\n    key: \"onparserinit\",\n    value: function onparserinit(parser) {\n      this.parser = parser;\n    }\n    // Resets the handler back to starting state\n  }, {\n    key: \"onreset\",\n    value: function onreset() {\n      this.dom = [];\n      this.root = new Document(this.dom);\n      this.done = false;\n      this.tagStack = [this.root];\n      this.lastNode = null;\n      this.parser = null;\n    }\n    // Signals the handler that parsing is done\n  }, {\n    key: \"onend\",\n    value: function onend() {\n      if (this.done) return;\n      this.done = true;\n      this.parser = null;\n      this.handleCallback(null);\n    }\n  }, {\n    key: \"onerror\",\n    value: function onerror(error) {\n      this.handleCallback(error);\n    }\n  }, {\n    key: \"onclosetag\",\n    value: function onclosetag() {\n      this.lastNode = null;\n      var elem = this.tagStack.pop();\n      if (this.options.withEndIndices) {\n        elem.endIndex = this.parser.endIndex;\n      }\n      if (this.elementCB) this.elementCB(elem);\n    }\n  }, {\n    key: \"onopentag\",\n    value: function onopentag(name, attribs) {\n      var type = this.options.xmlMode ? ElementType.Tag : undefined;\n      var element = new Element(name, attribs, undefined, type);\n      this.addNode(element);\n      this.tagStack.push(element);\n    }\n  }, {\n    key: \"ontext\",\n    value: function ontext(data) {\n      var lastNode = this.lastNode;\n      if (lastNode && lastNode.type === ElementType.Text) {\n        lastNode.data += data;\n        if (this.options.withEndIndices) {\n          lastNode.endIndex = this.parser.endIndex;\n        }\n      } else {\n        var node = new Text(data);\n        this.addNode(node);\n        this.lastNode = node;\n      }\n    }\n  }, {\n    key: \"oncomment\",\n    value: function oncomment(data) {\n      if (this.lastNode && this.lastNode.type === ElementType.Comment) {\n        this.lastNode.data += data;\n        return;\n      }\n      var node = new Comment(data);\n      this.addNode(node);\n      this.lastNode = node;\n    }\n  }, {\n    key: \"oncommentend\",\n    value: function oncommentend() {\n      this.lastNode = null;\n    }\n  }, {\n    key: \"oncdatastart\",\n    value: function oncdatastart() {\n      var text = new Text(\"\");\n      var node = new CDATA([text]);\n      this.addNode(node);\n      text.parent = node;\n      this.lastNode = text;\n    }\n  }, {\n    key: \"oncdataend\",\n    value: function oncdataend() {\n      this.lastNode = null;\n    }\n  }, {\n    key: \"onprocessinginstruction\",\n    value: function onprocessinginstruction(name, data) {\n      var node = new ProcessingInstruction(name, data);\n      this.addNode(node);\n    }\n  }, {\n    key: \"handleCallback\",\n    value: function handleCallback(error) {\n      if (typeof this.callback === \"function\") {\n        this.callback(error, this.dom);\n      } else if (error) {\n        throw error;\n      }\n    }\n  }, {\n    key: \"addNode\",\n    value: function addNode(node) {\n      var parent = this.tagStack[this.tagStack.length - 1];\n      var previousSibling = parent.children[parent.children.length - 1];\n      if (this.options.withStartIndices) {\n        node.startIndex = this.parser.startIndex;\n      }\n      if (this.options.withEndIndices) {\n        node.endIndex = this.parser.endIndex;\n      }\n      parent.children.push(node);\n      if (previousSibling) {\n        node.prev = previousSibling;\n        previousSibling.next = node;\n      }\n      node.parent = parent;\n      this.lastNode = null;\n    }\n  }]);\n  return DomHandler;\n}();\nexport default DomHandler;","map":{"version":3,"names":["ElementType","Element","Text","Comment","CDATA","Document","ProcessingInstruction","defaultOpts","withStartIndices","withEndIndices","xmlMode","DomHandler","callback","options","elementCB","dom","root","done","tagStack","lastNode","parser","undefined","handleCallback","error","elem","pop","endIndex","name","attribs","type","Tag","element","addNode","push","data","node","text","parent","length","previousSibling","children","startIndex","prev","next"],"sources":["C:/programowanko/react/schedule-formatter/schedule-formatter/node_modules/cheerio-select/node_modules/domhandler/lib/esm/index.js"],"sourcesContent":["import { ElementType } from \"domelementtype\";\nimport { Element, Text, Comment, CDATA, Document, ProcessingInstruction, } from \"./node.js\";\nexport * from \"./node.js\";\n// Default options\nconst defaultOpts = {\n    withStartIndices: false,\n    withEndIndices: false,\n    xmlMode: false,\n};\nexport class DomHandler {\n    /**\n     * @param callback Called once parsing has completed.\n     * @param options Settings for the handler.\n     * @param elementCB Callback whenever a tag is closed.\n     */\n    constructor(callback, options, elementCB) {\n        /** The elements of the DOM */\n        this.dom = [];\n        /** The root element for the DOM */\n        this.root = new Document(this.dom);\n        /** Indicated whether parsing has been completed. */\n        this.done = false;\n        /** Stack of open tags. */\n        this.tagStack = [this.root];\n        /** A data node that is still being written to. */\n        this.lastNode = null;\n        /** Reference to the parser instance. Used for location information. */\n        this.parser = null;\n        // Make it possible to skip arguments, for backwards-compatibility\n        if (typeof options === \"function\") {\n            elementCB = options;\n            options = defaultOpts;\n        }\n        if (typeof callback === \"object\") {\n            options = callback;\n            callback = undefined;\n        }\n        this.callback = callback !== null && callback !== void 0 ? callback : null;\n        this.options = options !== null && options !== void 0 ? options : defaultOpts;\n        this.elementCB = elementCB !== null && elementCB !== void 0 ? elementCB : null;\n    }\n    onparserinit(parser) {\n        this.parser = parser;\n    }\n    // Resets the handler back to starting state\n    onreset() {\n        this.dom = [];\n        this.root = new Document(this.dom);\n        this.done = false;\n        this.tagStack = [this.root];\n        this.lastNode = null;\n        this.parser = null;\n    }\n    // Signals the handler that parsing is done\n    onend() {\n        if (this.done)\n            return;\n        this.done = true;\n        this.parser = null;\n        this.handleCallback(null);\n    }\n    onerror(error) {\n        this.handleCallback(error);\n    }\n    onclosetag() {\n        this.lastNode = null;\n        const elem = this.tagStack.pop();\n        if (this.options.withEndIndices) {\n            elem.endIndex = this.parser.endIndex;\n        }\n        if (this.elementCB)\n            this.elementCB(elem);\n    }\n    onopentag(name, attribs) {\n        const type = this.options.xmlMode ? ElementType.Tag : undefined;\n        const element = new Element(name, attribs, undefined, type);\n        this.addNode(element);\n        this.tagStack.push(element);\n    }\n    ontext(data) {\n        const { lastNode } = this;\n        if (lastNode && lastNode.type === ElementType.Text) {\n            lastNode.data += data;\n            if (this.options.withEndIndices) {\n                lastNode.endIndex = this.parser.endIndex;\n            }\n        }\n        else {\n            const node = new Text(data);\n            this.addNode(node);\n            this.lastNode = node;\n        }\n    }\n    oncomment(data) {\n        if (this.lastNode && this.lastNode.type === ElementType.Comment) {\n            this.lastNode.data += data;\n            return;\n        }\n        const node = new Comment(data);\n        this.addNode(node);\n        this.lastNode = node;\n    }\n    oncommentend() {\n        this.lastNode = null;\n    }\n    oncdatastart() {\n        const text = new Text(\"\");\n        const node = new CDATA([text]);\n        this.addNode(node);\n        text.parent = node;\n        this.lastNode = text;\n    }\n    oncdataend() {\n        this.lastNode = null;\n    }\n    onprocessinginstruction(name, data) {\n        const node = new ProcessingInstruction(name, data);\n        this.addNode(node);\n    }\n    handleCallback(error) {\n        if (typeof this.callback === \"function\") {\n            this.callback(error, this.dom);\n        }\n        else if (error) {\n            throw error;\n        }\n    }\n    addNode(node) {\n        const parent = this.tagStack[this.tagStack.length - 1];\n        const previousSibling = parent.children[parent.children.length - 1];\n        if (this.options.withStartIndices) {\n            node.startIndex = this.parser.startIndex;\n        }\n        if (this.options.withEndIndices) {\n            node.endIndex = this.parser.endIndex;\n        }\n        parent.children.push(node);\n        if (previousSibling) {\n            node.prev = previousSibling;\n            previousSibling.next = node;\n        }\n        node.parent = parent;\n        this.lastNode = null;\n    }\n}\nexport default DomHandler;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}