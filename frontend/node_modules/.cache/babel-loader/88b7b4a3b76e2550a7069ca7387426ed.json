{"ast":null,"code":"import _toConsumableArray from \"C:/programowanko/react/schedule-formatter/schedule-formatter/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport boolbase from \"boolbase\";\nimport { isTraversal } from \"../sort.js\";\n/** Used as a placeholder for :has. Will be replaced with the actual element. */\nexport var PLACEHOLDER_ELEMENT = {};\nexport function ensureIsTag(next, adapter) {\n  if (next === boolbase.falseFunc) return boolbase.falseFunc;\n  return function (elem) {\n    return adapter.isTag(elem) && next(elem);\n  };\n}\nexport function getNextSiblings(elem, adapter) {\n  var siblings = adapter.getSiblings(elem);\n  if (siblings.length <= 1) return [];\n  var elemIndex = siblings.indexOf(elem);\n  if (elemIndex < 0 || elemIndex === siblings.length - 1) return [];\n  return siblings.slice(elemIndex + 1).filter(adapter.isTag);\n}\nfunction copyOptions(options) {\n  // Not copied: context, rootFunc\n  return {\n    xmlMode: !!options.xmlMode,\n    lowerCaseAttributeNames: !!options.lowerCaseAttributeNames,\n    lowerCaseTags: !!options.lowerCaseTags,\n    quirksMode: !!options.quirksMode,\n    cacheResults: !!options.cacheResults,\n    pseudos: options.pseudos,\n    adapter: options.adapter,\n    equals: options.equals\n  };\n}\nvar is = function is(next, token, options, context, compileToken) {\n  var func = compileToken(token, copyOptions(options), context);\n  return func === boolbase.trueFunc ? next : func === boolbase.falseFunc ? boolbase.falseFunc : function (elem) {\n    return func(elem) && next(elem);\n  };\n};\n/*\n * :not, :has, :is, :matches and :where have to compile selectors\n * doing this in src/pseudos.ts would lead to circular dependencies,\n * so we add them here\n */\nexport var subselects = {\n  is: is,\n  /**\n   * `:matches` and `:where` are aliases for `:is`.\n   */\n  matches: is,\n  where: is,\n  not: function not(next, token, options, context, compileToken) {\n    var func = compileToken(token, copyOptions(options), context);\n    return func === boolbase.falseFunc ? next : func === boolbase.trueFunc ? boolbase.falseFunc : function (elem) {\n      return !func(elem) && next(elem);\n    };\n  },\n  has: function has(next, subselect, options, _context, compileToken) {\n    var adapter = options.adapter;\n    var opts = copyOptions(options);\n    opts.relativeSelector = true;\n    var context = subselect.some(function (s) {\n      return s.some(isTraversal);\n    }) ?\n    // Used as a placeholder. Will be replaced with the actual element.\n    [PLACEHOLDER_ELEMENT] : undefined;\n    var compiled = compileToken(subselect, opts, context);\n    if (compiled === boolbase.falseFunc) return boolbase.falseFunc;\n    var hasElement = ensureIsTag(compiled, adapter);\n    // If `compiled` is `trueFunc`, we can skip this.\n    if (context && compiled !== boolbase.trueFunc) {\n      /*\n       * `shouldTestNextSiblings` will only be true if the query starts with\n       * a traversal (sibling or adjacent). That means we will always have a context.\n       */\n      var _compiled$shouldTestN = compiled.shouldTestNextSiblings,\n        shouldTestNextSiblings = _compiled$shouldTestN === void 0 ? false : _compiled$shouldTestN;\n      return function (elem) {\n        if (!next(elem)) return false;\n        context[0] = elem;\n        var childs = adapter.getChildren(elem);\n        var nextElements = shouldTestNextSiblings ? [].concat(_toConsumableArray(childs), _toConsumableArray(getNextSiblings(elem, adapter))) : childs;\n        return adapter.existsOne(hasElement, nextElements);\n      };\n    }\n    return function (elem) {\n      return next(elem) && adapter.existsOne(hasElement, adapter.getChildren(elem));\n    };\n  }\n};","map":{"version":3,"mappings":"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","names":["boolbase","isTraversal","PLACEHOLDER_ELEMENT","ensureIsTag","next","adapter","falseFunc","elem","isTag","getNextSiblings","siblings","getSiblings","length","elemIndex","indexOf","slice","filter","copyOptions","options","xmlMode","lowerCaseAttributeNames","lowerCaseTags","quirksMode","cacheResults","pseudos","equals","is","token","context","compileToken","func","trueFunc","subselects","matches","where","not","has","subselect","_context","opts","relativeSelector","some","s","undefined","compiled","hasElement","shouldTestNextSiblings","childs","getChildren","nextElements","existsOne"],"sources":["pseudo-selectors/subselects.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}