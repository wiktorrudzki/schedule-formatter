{"ast":null,"code":"import _toConsumableArray from \"C:/programowanko/react/schedule-formatter/schedule-formatter/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport { AttributeAction, SelectorType } from \"css-what\";\nvar procedure = new Map([[SelectorType.Universal, 50], [SelectorType.Tag, 30], [SelectorType.Attribute, 1], [SelectorType.Pseudo, 0]]);\nexport function isTraversal(token) {\n  return !procedure.has(token.type);\n}\nvar attributes = new Map([[AttributeAction.Exists, 10], [AttributeAction.Equals, 8], [AttributeAction.Not, 7], [AttributeAction.Start, 6], [AttributeAction.End, 6], [AttributeAction.Any, 5]]);\n/**\n * Sort the parts of the passed selector,\n * as there is potential for optimization\n * (some types of selectors are faster than others)\n *\n * @param arr Selector to sort\n */\nexport default function sortByProcedure(arr) {\n  var procs = arr.map(getProcedure);\n  for (var i = 1; i < arr.length; i++) {\n    var procNew = procs[i];\n    if (procNew < 0) continue;\n    for (var j = i - 1; j >= 0 && procNew < procs[j]; j--) {\n      var token = arr[j + 1];\n      arr[j + 1] = arr[j];\n      arr[j] = token;\n      procs[j + 1] = procs[j];\n      procs[j] = procNew;\n    }\n  }\n}\nfunction getProcedure(token) {\n  var _a, _b;\n  var proc = (_a = procedure.get(token.type)) !== null && _a !== void 0 ? _a : -1;\n  if (token.type === SelectorType.Attribute) {\n    proc = (_b = attributes.get(token.action)) !== null && _b !== void 0 ? _b : 4;\n    if (token.action === AttributeAction.Equals && token.name === \"id\") {\n      // Prefer ID selectors (eg. #ID)\n      proc = 9;\n    }\n    if (token.ignoreCase) {\n      /*\n       * IgnoreCase adds some overhead, prefer \"normal\" token\n       * this is a binary operation, to ensure it's still an int\n       */\n      proc >>= 1;\n    }\n  } else if (token.type === SelectorType.Pseudo) {\n    if (!token.data) {\n      proc = 3;\n    } else if (token.name === \"has\" || token.name === \"contains\") {\n      proc = 0; // Expensive in any case\n    } else if (Array.isArray(token.data)) {\n      // Eg. :matches, :not\n      proc = Math.min.apply(Math, _toConsumableArray(token.data.map(function (d) {\n        return Math.min.apply(Math, _toConsumableArray(d.map(getProcedure)));\n      })));\n      // If we have traversals, try to avoid executing this selector\n      if (proc < 0) {\n        proc = 0;\n      }\n    } else {\n      proc = 2;\n    }\n  }\n  return proc;\n}","map":{"version":3,"mappings":"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","names":["AttributeAction","SelectorType","procedure","Map","Universal","Tag","Attribute","Pseudo","isTraversal","token","has","type","attributes","Exists","Equals","Not","Start","End","Any","sortByProcedure","arr","procs","map","getProcedure","i","length","procNew","j","proc","get","action","name","ignoreCase","data","Array","isArray","Math","min","d"],"sources":["sort.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}