{"ast":null,"code":"import { isTag, isText } from \"domhandler\";\nimport { filter, findOne } from \"./querying.js\";\nconst Checks = {\n  tag_name(name) {\n    if (typeof name === \"function\") {\n      return elem => isTag(elem) && name(elem.name);\n    } else if (name === \"*\") {\n      return isTag;\n    }\n    return elem => isTag(elem) && elem.name === name;\n  },\n  tag_type(type) {\n    if (typeof type === \"function\") {\n      return elem => type(elem.type);\n    }\n    return elem => elem.type === type;\n  },\n  tag_contains(data) {\n    if (typeof data === \"function\") {\n      return elem => isText(elem) && data(elem.data);\n    }\n    return elem => isText(elem) && elem.data === data;\n  }\n};\n/**\n * @param attrib Attribute to check.\n * @param value Attribute value to look for.\n * @returns A function to check whether the a node has an attribute with a\n *   particular value.\n */\nfunction getAttribCheck(attrib, value) {\n  if (typeof value === \"function\") {\n    return elem => isTag(elem) && value(elem.attribs[attrib]);\n  }\n  return elem => isTag(elem) && elem.attribs[attrib] === value;\n}\n/**\n * @param a First function to combine.\n * @param b Second function to combine.\n * @returns A function taking a node and returning `true` if either of the input\n *   functions returns `true` for the node.\n */\nfunction combineFuncs(a, b) {\n  return elem => a(elem) || b(elem);\n}\n/**\n * @param options An object describing nodes to look for.\n * @returns A function executing all checks in `options` and returning `true` if\n *   any of them match a node.\n */\nfunction compileTest(options) {\n  const funcs = Object.keys(options).map(key => {\n    const value = options[key];\n    return Object.prototype.hasOwnProperty.call(Checks, key) ? Checks[key](value) : getAttribCheck(key, value);\n  });\n  return funcs.length === 0 ? null : funcs.reduce(combineFuncs);\n}\n/**\n * @category Legacy Query Functions\n * @param options An object describing nodes to look for.\n * @param node The element to test.\n * @returns Whether the element matches the description in `options`.\n */\nexport function testElement(options, node) {\n  const test = compileTest(options);\n  return test ? test(node) : true;\n}\n/**\n * @category Legacy Query Functions\n * @param options An object describing nodes to look for.\n * @param nodes Nodes to search through.\n * @param recurse Also consider child nodes.\n * @param limit Maximum number of nodes to return.\n * @returns All nodes that match `options`.\n */\nexport function getElements(options, nodes, recurse) {\n  let limit = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Infinity;\n  const test = compileTest(options);\n  return test ? filter(test, nodes, recurse, limit) : [];\n}\n/**\n * @category Legacy Query Functions\n * @param id The unique ID attribute value to look for.\n * @param nodes Nodes to search through.\n * @param recurse Also consider child nodes.\n * @returns The node with the supplied ID.\n */\nexport function getElementById(id, nodes) {\n  let recurse = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  if (!Array.isArray(nodes)) nodes = [nodes];\n  return findOne(getAttribCheck(\"id\", id), nodes, recurse);\n}\n/**\n * @category Legacy Query Functions\n * @param tagName Tag name to search for.\n * @param nodes Nodes to search through.\n * @param recurse Also consider child nodes.\n * @param limit Maximum number of nodes to return.\n * @returns All nodes with the supplied `tagName`.\n */\nexport function getElementsByTagName(tagName, nodes) {\n  let recurse = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  let limit = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Infinity;\n  return filter(Checks[\"tag_name\"](tagName), nodes, recurse, limit);\n}\n/**\n * @category Legacy Query Functions\n * @param type Element type to look for.\n * @param nodes Nodes to search through.\n * @param recurse Also consider child nodes.\n * @param limit Maximum number of nodes to return.\n * @returns All nodes with the supplied `type`.\n */\nexport function getElementsByTagType(type, nodes) {\n  let recurse = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  let limit = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Infinity;\n  return filter(Checks[\"tag_type\"](type), nodes, recurse, limit);\n}","map":{"version":3,"mappings":"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","names":["isTag","isText","filter","findOne","Checks","tag_name","name","elem","tag_type","type","tag_contains","data","getAttribCheck","attrib","value","attribs","combineFuncs","a","b","compileTest","options","funcs","Object","keys","map","key","prototype","hasOwnProperty","call","length","reduce","testElement","node","test","getElements","nodes","recurse","limit","Infinity","getElementById","id","Array","isArray","getElementsByTagName","tagName","getElementsByTagType"],"sources":["legacy.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}